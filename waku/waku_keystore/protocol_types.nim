when (NimMajor, NimMinor) < (1, 4):
  {.push raises: [Defect].}
else:
  {.push raises: [].}

import std/[sequtils, tables], stew/[results, endians2], nimcrypto, stint

# NOTE: 256-bytes long credentials are due to the use of BN254 in RLN. Other implementations/curves might have a different byte size
const CredentialByteSize* = 256

type
  IdentityTrapdoor* = seq[byte] #array[32, byte]
  IdentityNullifier* = seq[byte] #array[32, byte]
  # identity key as defined in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IdentitySecretHash* = seq[byte] #array[32, byte]
  # hash of identity key as defined ed in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IDCommitment* = seq[byte] #array[32, byte]

when defined(rln_v2):
  type UserMessageLimit* = uint64

type IdentityCredential* = object
  idTrapdoor*: IdentityTrapdoor
  idNullifier*: IdentityNullifier
  ## user's identity key (a secret key) which is selected randomly
  ## see details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idSecretHash*: IdentitySecretHash
  # hash of user's identity key generated by
  # Poseidon hash function implemented in rln lib
  # more details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idCommitment*: IDCommitment

proc toUInt256*(idCommitment: IDCommitment): UInt256 =
  let pk = UInt256.fromBytesLE(idCommitment)
  return pk

proc toIDCommitment*(idCommitmentUint: UInt256): IDCommitment =
  let pk = IDCommitment(@(idCommitmentUint.toBytesLE()))
  return pk

type MembershipIndex* = uint

proc toMembershipIndex*(v: UInt256): MembershipIndex =
  return cast[MembershipIndex](v)

# Converts a sequence of tuples containing 4 string (i.e. identity trapdoor, nullifier, secret hash, commitment) to an IdentityCredential
type RawMembershipCredentials* = (string, string, string, string)
proc toIdentityCredentials*(
    groupKeys: seq[RawMembershipCredentials]
): Result[seq[IdentityCredential], string] =
  ## groupKeys is  sequence of membership key tuples in the form of (identity key, identity commitment) all in the hexadecimal format
  ## the toIdentityCredentials proc populates a sequence of IdentityCredentials using the supplied groupKeys
  ## Returns an error if the conversion fails

  var groupIdCredentials = newSeq[IdentityCredential]()

  for i in 0 .. groupKeys.len - 1:
    try:
      let
        idTrapdoor = IdentityTrapdoor(
          @(hexToUint[CredentialByteSize](groupKeys[i][0]).toBytesLE())
        )
        idNullifier = IdentityNullifier(
          @(hexToUint[CredentialByteSize](groupKeys[i][1]).toBytesLE())
        )
        idSecretHash = IdentitySecretHash(
          @(hexToUint[CredentialByteSize](groupKeys[i][2]).toBytesLE())
        )
        idCommitment =
          IDCommitment(@(hexToUint[CredentialByteSize](groupKeys[i][3]).toBytesLE()))
      groupIdCredentials.add(
        IdentityCredential(
          idTrapdoor: idTrapdoor,
          idNullifier: idNullifier,
          idSecretHash: idSecretHash,
          idCommitment: idCommitment,
        )
      )
    except ValueError as err:
      return err("could not convert the group key to bytes: " & err.msg)
  return ok(groupIdCredentials)

proc serialize*(idComms: seq[IDCommitment]): seq[byte] =
  ## serializes a seq of IDCommitments to a byte seq
  ## the serialization is based on https://github.com/status-im/nwaku/blob/37bd29fbc37ce5cf636734e7dd410b1ed27b88c8/waku/v2/protocol/waku_rln_relay/rln.nim#L142
  ## the order of serialization is |id_commitment_len<8>|id_commitment<var>|
  var idCommsBytes = newSeq[byte]()

  # serialize the idComms, with its length prefixed
  let len = toBytes(uint64(idComms.len), Endianness.littleEndian)
  idCommsBytes.add(len)

  for idComm in idComms:
    idCommsBytes = concat(idCommsBytes, @idComm)

  return idCommsBytes

type MembershipContract* = object
  chainId*: string
  address*: string

type KeystoreMembership* = ref object of RootObj
  membershipContract*: MembershipContract
  treeIndex*: MembershipIndex
  identityCredential*: IdentityCredential
  when defined(rln_v2):
    userMessageLimit*: UserMessageLimit

when defined(rln_v2):
  proc `$`*(m: KeystoreMembership): string =
    return
      "KeystoreMembership(chainId: " & m.membershipContract.chainId &
      ", contractAddress: " & m.membershipContract.address & ", treeIndex: " &
      $m.treeIndex & ", userMessageLimit: " & $m.userMessageLimit &
      ", identityCredential: " & $m.identityCredential & ")"

else:
  proc `$`*(m: KeystoreMembership): string =
    return
      "KeystoreMembership(chainId: " & m.membershipContract.chainId &
      ", contractAddress: " & m.membershipContract.address & ", treeIndex: " &
      $m.treeIndex & ", identityCredential: " & $m.identityCredential & ")"

when defined(rln_v2):
  proc `==`*(x, y: KeystoreMembership): bool =
    return
      x.membershipContract.chainId == y.membershipContract.chainId and
      x.membershipContract.address == y.membershipContract.address and
      x.treeIndex == y.treeIndex and x.userMessageLimit == y.userMessageLimit and
      x.identityCredential.idTrapdoor == y.identityCredential.idTrapdoor and
      x.identityCredential.idNullifier == y.identityCredential.idNullifier and
      x.identityCredential.idSecretHash == y.identityCredential.idSecretHash and
      x.identityCredential.idCommitment == y.identityCredential.idCommitment

else:
  proc `==`*(x, y: KeystoreMembership): bool =
    return
      x.membershipContract.chainId == y.membershipContract.chainId and
      x.membershipContract.address == y.membershipContract.address and
      x.treeIndex == y.treeIndex and
      x.identityCredential.idTrapdoor == y.identityCredential.idTrapdoor and
      x.identityCredential.idNullifier == y.identityCredential.idNullifier and
      x.identityCredential.idSecretHash == y.identityCredential.idSecretHash and
      x.identityCredential.idCommitment == y.identityCredential.idCommitment

proc hash*(m: KeystoreMembership): string =
  # hash together the chainId, address and treeIndex
  return
    $sha256.digest(
      m.membershipContract.chainId & m.membershipContract.address & $m.treeIndex
    )

type MembershipTable* = Table[string, KeystoreMembership]

type AppInfo* = object
  application*: string
  appIdentifier*: string
  version*: string

type AppKeystore* = object
  application*: string
  appIdentifier*: string
  credentials*: MembershipTable
  version*: string

type
  AppKeystoreErrorKind* = enum
    KeystoreOsError = "keystore error: OS specific error"
    KeystoreIoError = "keystore error: IO specific error"
    KeystoreJsonKeyError = "keystore error: fields not present in JSON"
    KeystoreJsonError = "keystore error: JSON encoder/decoder error"
    KeystoreKeystoreDoesNotExist = "keystore error: file does not exist"
    KeystoreCreateKeystoreError = "Error while creating application keystore"
    KeystoreLoadKeystoreError = "Error while loading application keystore"
    KeystoreCreateKeyfileError = "Error while creating keyfile for credentials"
    KeystoreSaveKeyfileError = "Error while saving keyfile for credentials"
    KeystoreReadKeyfileError = "Error while reading keyfile for credentials"
    KeystoreCredentialAlreadyPresentError =
      "Error while adding credentials to keystore: credential already present"
    KeystoreCredentialNotFoundError =
      "Error while searching credentials in keystore: credential not found"

  AppKeystoreError* = object
    kind*: AppKeystoreErrorKind
    msg*: string

proc `$`*(e: AppKeystoreError): string =
  return $e.kind & ": " & e.msg

type KeystoreResult*[T] = Result[T, AppKeystoreError]
