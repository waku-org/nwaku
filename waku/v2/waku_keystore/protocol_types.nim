when (NimMajor, NimMinor) < (1, 4):
  {.push raises: [Defect].}
else:
  {.push raises: [].}

import 
  std/sequtils,
  stew/[results, endians2],
  stint

# NOTE: 256-bytes long credentials are due to the use of BN254 in RLN. Other implementations/curves might have a different byte size
const CredentialByteSize* = 256

type
  IdentityTrapdoor* = seq[byte] #array[32, byte]
  IdentityNullifier* = seq[byte] #array[32, byte]
  # identity key as defined in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IdentitySecretHash* = seq[byte] #array[32, byte]
  # hash of identity key as defined ed in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  IDCommitment* = seq[byte] #array[32, byte]

type IdentityCredential* = object
  idTrapdoor*: IdentityTrapdoor
  idNullifier*: IdentityNullifier
  ## user's identity key (a secret key) which is selected randomly
  ## see details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idSecretHash*: IdentitySecretHash
  # hash of user's identity key generated by
  # Poseidon hash function implemented in rln lib
  # more details in https://hackmd.io/tMTLMYmTR5eynw2lwK9n1w?view#Membership
  idCommitment*: IDCommitment

proc toUInt256*(idCommitment: IDCommitment): UInt256 =
  let pk = UInt256.fromBytesLE(idCommitment)
  return pk

proc toIDCommitment*(idCommitmentUint: UInt256): IDCommitment =
  let pk = IDCommitment(@(idCommitmentUint.toBytesLE()))
  return pk

type MembershipIndex* = uint

proc toMembershipIndex*(v: UInt256): MembershipIndex =
  let membershipIndex: MembershipIndex = cast[MembershipIndex](v)
  return membershipIndex

# Converts a sequence of tuples containing 4 string (i.e. identity trapdoor, nullifier, secret hash and commitment) to an IndentityCredential
type RawMembershipCredentials* = (string, string, string, string)
proc toIdentityCredentials*(groupKeys: seq[RawMembershipCredentials]): Result[seq[
    IdentityCredential], string] =
  ## groupKeys is  sequence of membership key tuples in the form of (identity key, identity commitment) all in the hexadecimal format
  ## the toIdentityCredentials proc populates a sequence of IdentityCredentials using the supplied groupKeys
  ## Returns an error if the conversion fails

  var groupIdCredentials = newSeq[IdentityCredential]()

  for i in 0..groupKeys.len-1:
    try:
      let
        idTrapdoor = IdentityTrapdoor(@(hexToUint[CredentialByteSize](groupKeys[i][0]).toBytesLE()))
        idNullifier = IdentityNullifier(@(hexToUint[CredentialByteSize](groupKeys[i][1]).toBytesLE()))
        idSecretHash = IdentitySecretHash(@(hexToUint[CredentialByteSize](groupKeys[i][2]).toBytesLE()))
        idCommitment = IDCommitment(@(hexToUint[CredentialByteSize](groupKeys[i][3]).toBytesLE()))
      groupIdCredentials.add(IdentityCredential(idTrapdoor: idTrapdoor, 
                                                idNullifier: idNullifier, 
                                                idSecretHash: idSecretHash,
                                                idCommitment: idCommitment))
    except ValueError as err:
      return err("could not convert the group key to bytes: " & err.msg)
  return ok(groupIdCredentials)

proc serialize*(idComms: seq[IDCommitment]): seq[byte] =
  ## serializes a seq of IDCommitments to a byte seq
  ## the serialization is based on https://github.com/status-im/nwaku/blob/37bd29fbc37ce5cf636734e7dd410b1ed27b88c8/waku/v2/protocol/waku_rln_relay/rln.nim#L142
  ## the order of serialization is |id_commitment_len<8>|id_commitment<var>|
  var idCommsBytes = newSeq[byte]()

  # serialize the idComms, with its length prefixed
  let len = toBytes(uint64(idComms.len), Endianness.littleEndian)
  idCommsBytes.add(len)

  for idComm in idComms:
    idCommsBytes = concat(idCommsBytes, @idComm)

  return idCommsBytes

type MembershipContract* = object
  chainId*: string
  address*: string

type MembershipGroup* = object
  membershipContract*: MembershipContract
  treeIndex*: MembershipIndex

type MembershipCredentials* = object
   identityCredential*: IdentityCredential
   membershipGroups*: seq[MembershipGroup]

type AppInfo* = object
  application*: string
  appIdentifier*: string
  version*: string

type AppKeystore* = object
  application*: string
  appIdentifier*: string
  credentials*: seq[MembershipCredentials]
  version*: string

type
  AppKeystoreError* = enum
    KeystoreOsError               = "keystore error: OS specific error"
    KeystoreIoError               = "keystore error: IO specific error"
    KeystoreJsonKeyError          = "keystore error: fields not present in JSON"
    KeystoreJsonError             = "keystore error: JSON encoder/decoder error"
    KeystoreKeystoreDoesNotExist  = "keystore error: file does not exist"
    KeystoreCreateKeystoreError   = "Error while creating application keystore"
    KeystoreLoadKeystoreError     = "Error while loading application keystore"
    KeystoreCreateKeyfileError    = "Error while creating keyfile for credentials"
    KeystoreSaveKeyfileError      = "Error while saving keyfile for credentials"
    KeystoreReadKeyfileError      = "Error while reading keyfile for credentials"

type KeystoreResult*[T] = Result[T, AppKeystoreError]